django rest framework框架
	pip install djangorestframework

1、 所有类继承APIView 
	from rest_framework.views import APIView
	class MyView(APIView):
		pass

2、 APIView的dispatch方法对原生request进行加工
				
	dispatch()：
		- 在原有的功能上对request进行加工 
		- 创建一个Request 本质是原生request的基础上丰富了一些功能
		request = initialize_request(self, request)：
					# 添加一些功能	
					return Request(self, request)：
							# Request里调用的方法 get_authenticators(request)：



认证类的设置：
	- 类视图里面设置
		authentication_classes = [MyAuthentication,]
	- 配置文件中设置
		REST_FRAMEWORK = {
		#全局使用的认证类
		'DEFAULT_AUTHENTICATION_CLASSES': ['认证类的路径'],
		'UNAUTHENTICATED_USER':None, # 匿名 request.uesr = None
		'UNAUTHENTICATED_TOKEN':None, # 匿名 request.auth = None
		}

1、认证		
	梳理：
		1、使用
			- 创建类：继承BaseAuthentication：实现：authenticate方法
			- 返回值：
				- None 我不管 下一个认证来执行
			    - raise exceptions.AuthenticationFailed('用户认证失败') # from rest_framework import exceptions
				- (元素1, 元素2) 元素1赋值给request.user 元素2赋值给request.auth

			- 局部使用
				from rest_framework.views import APIView
				from rest_framework.authentication import BasicAuthencation

				class MyAuthenticate(self, request):
					def authenticate(self, request):
						token = request._request.GET.get('token')
						# 获取用户名和密码 去数据校验
						if not token:
							raise exceptions.AuthencationFailed('用户认证失败')
						return ('xxx', None)
					def authenticate_header(self, val):
						pass

				class Myclass(APIView):
					authentication_classes = [MyAuthentication,]

			- 全局使用
				配置文件中设置
					REST_FRAMEWORK = {
					#全局使用的认证类
					'DEFAULT_AUTHENTICATION_CLASSES': ['认证类的路径'],
					'UNAUTHENTICATED_USER':None, # 匿名 request.uesr = None
					'UNAUTHENTICATED_TOKEN':None, # 匿名 request.auth = None
					}

		2、源码流程
			- dispatch
				- 封装request
					- 获取定义的认证类(全局/局部),通过列表生成时创建对象
				- initial
					- perform_authentication
						request.user(内部循环...实现认证功能)

2、权限
	问题：不用视图不用权限可以访问
	基本使用：
		class MyPermission(object):
			def has_permission(self, request, view):
				# 权限判断
				return True
		class OrderView(APIView):
			permission_classes = [MyPermission,]
			def get(self, request)：
				ret = {
				'code': 1000,
				'msg': None,
				'data': None
				}
				try:
					ret['data'] = xxx
					except Exception as e:
						pass
					return JsonResponse(ret)
	源码流程：
		- dispatch

	梳理：
		1、使用
			- 类 必须继承：BasePermission 必须实现has_permission方法
			from rest_framework.permissions import BasePermission
			class SVIPermission(BasePermission):
				message = '必须是svip才可以访问'
				def has_permission(self, request, view):
					# 权限判断
					return True
			- 返回值
				- True 有权访问
				- False 无权访问

			- 全局
				REST_FRAMEWORK = {
					#全局使用的权限类
					'DEFAULT_PERMISSION_CLASSES': ['权限类的路径'],
					}
			- 局部
				class OrderView(APIView):
				permission_classes = [MyPermission,]
				def get(self, request)：
					pass

限流


版本
	在url中传参
		urlpatterns = [
			url(r'^(?P<version>[v1|v2]+')/user/$', views.UsersView.as_view()),
		]

		REST_FRAMEWORK = {
					'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.URLPathVersioning',
					'DEFAULT_VERSION': 'v1',
					'ALLOWED_VERSIONS'： ['v1', 'v2'],
					'VERSION_PARAM'： 'version',
					}	

		class UsersView(APIView):
			def get(self, request, *args, **kwargs):
				print(request.version)
				return HttpResponse('用户列表')







